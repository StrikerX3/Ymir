#include "midi_service.hpp"

#include <app/settings.hpp>

#include <util/stdio_suppress.hpp>

#include <unordered_set>
#include <vector>

namespace app::services {

MIDIService::MIDIService(util::ServiceLocator &serviceLocator)
    : m_serviceLocator(serviceLocator) {
    std::vector<RtMidi::Api> apis{};
    std::unordered_set<RtMidi::Api> failedAPIs{};
    RtMidi::getCompiledApi(apis);
    auto makeRtMidi = [&]<typename T>(const char *name) -> std::unique_ptr<T> {
        for (auto api : apis) {
            if (failedAPIs.contains(api)) {
                continue;
            }
            try {
                return std::make_unique<T>(api, name);
            } catch (const RtMidiError &) {
                // just ignore it and try the next API
                failedAPIs.insert(api);
            }
        }
        return {};
    };

    // Suppress warnings generated by RtMidi during instantiation
    util::StdErrSuppressor suppressor{};

    m_input = util::WrapRtMidi(makeRtMidi.operator()<RtMidiIn>("Ymir MIDI input client"));
    m_output = util::WrapRtMidi(makeRtMidi.operator()<RtMidiOut>("Ymir MIDI output client"));
    m_input->ignoreTypes(false, false, false);
}

MIDIService::~MIDIService() = default;

std::string MIDIService::GetMidiVirtualInputPortName() const {
    return "Ymir Virtual MIDI Input";
}

std::string MIDIService::GetMidiVirtualOutputPortName() const {
    return "Ymir Virtual MIDI Output";
}

using MidiPortType = Settings::Audio::MidiPort::Type;

std::string MIDIService::GetMidiInputPortName() const {
    auto &settings = m_serviceLocator.GetRequired<Settings>();

    switch (settings.audio.midiInputPort.Get().type) {
    case MidiPortType::None: {
        return "None";
    }
    case MidiPortType::Normal: {
        return settings.audio.midiInputPort.Get().id;
    }
    case MidiPortType::Virtual: {
        return GetMidiVirtualInputPortName();
    }
    }

    return {};
}

std::string MIDIService::GetMidiOutputPortName() const {
    auto &settings = m_serviceLocator.GetRequired<Settings>();

    switch (settings.audio.midiOutputPort.Get().type) {
    case MidiPortType::None: {
        return "None";
    }
    case MidiPortType::Normal: {
        return settings.audio.midiOutputPort.Get().id;
    }
    case MidiPortType::Virtual: {
        return GetMidiVirtualInputPortName();
    }
    }

    return {};
}

int MIDIService::FindInputPortByName(std::string name) const {
    unsigned int portCount = m_input->getPortCount();
    for (unsigned int i = 0; i < portCount; i++) {
        if (m_input->getPortName(i) == name) {
            return i;
        }
    }

    return -1;
}

int MIDIService::FindOutputPortByName(std::string name) const {
    unsigned int portCount = m_output->getPortCount();
    for (unsigned int i = 0; i < portCount; i++) {
        if (m_output->getPortName(i) == name) {
            return i;
        }
    }

    return -1;
}

} // namespace app::services
